import sqlite3
import sys
import os
sys.path.append('..')
from config import Config

class SQLLiteDBInterface():

    def __init__(self, db_name:str = None, table_name:str = None, caption_schema:str = None):
        # Connect to SQLite database (or create it if it doesn't exist)
        self.connection = sqlite3.connect(os.path.join(Config.base_db_path, Config.db_name if db_name is None else db_name))
        self.cursor = connection.cursor()

        self.table_name = Config.table_name if table_name is None else table_name

        #create the table during the init
        self.create_table()

        self.insertion_query = f"INSERT INTO {self.table_name} {tuple(Config.caption_schema.keys() if caption_schema is None else caption_schema.keys())} VALUES ({','.join(['?' for _ in range(Config.caption_schema.keys() if caption_schema is None else caption_schema.keys())])})"
    

    def create_table(self):

        # Create a table (if it doesn't exist)
        self.cursor.execute(f'''
            CREATE TABLE IF NOT EXISTS {self.table_name} (
                {','.join(key + ' ' + val for (key, val) in Config.caption_schema.items())}
            )
        ''')

        self.connection.commit()

    def execute_query(self, query: list, args:tuple = None):
        '''
        NOTE: query input is any SQL query generated by text2sql that 
        '''
        if args is None:
            self.cursor.execute(query)
        else:
            self.cursor.execute(query, args)

        return self.cursor.fetchall()  # return all rows relevant to query

    def insert_many_rows_list(self, rows_data: list):
        
        # Insert multiple rows at once using executemany()
        self.cursor.executemany(self.insertion_query, rows_data)

        self.connection.commit()
    
    def insert_many_rows_dict(self, rows_data: dict):

        # Execute query with extracted values
        self.cursor.executemany(self.insertion_query, [tuple(d.values()) for d in rows_data])

        # Commit changes and close connection
        self.connection.commit()

    def close_conn(self):

        self.cursor.close()





