import sqlite3
import os
from config import Config
from typing import List, Dict,Set
import pdb

class SQLLiteDBInterface():

    def __init__(self, db_name:str = None, table_name_schema_dict:Dict = None):
        # Connect to SQLite database (or create it if it doesn't exist)
        self.connection = sqlite3.connect(os.path.join(Config.sql_db_path, Config.sql_db_name if db_name is None else db_name))
        self.cursor = self.connection.cursor()

        if table_name_schema_dict is None:
            self.table_name_schema_dict = {Config.caption_table_name: [Config.caption_table_schema, Config.caption_table_pk]}
        else:
            self.table_name_schema_dict = table_name_schema_dict
        
        #create the table during the init
        # sqlite3.connect ALWAYS creates the table – this IF condition is meaningless
        self.create_table()
        # if not os.path.exists(os.path.join(Config.sql_db_path, Config.sql_db_name if db_name is None else db_name)):
        #     self.create_table()
        # #otherwiese populate the table schema dictionary from before
        # else:
        #     self.table_name_schema_dict = self.extract_schema_dict()

        # self.insertion_query = f"INSERT INTO {self.table_name} {tuple(Config.caption_schema.keys() if caption_schema is None else caption_schema.keys())} VALUES ({','.join(['?' for _ in range(Config.caption_schema.keys() if caption_schema is None else caption_schema.keys())])})"
        self.insertion_query = "INSERT OR IGNORE INTO {table_name} {table_schema} VALUES ({table_schema_value})"

    def add_new_table(self, table_name:str, table_schema:str, table_prim_key:str):
        self.table_name_schema_dict[table_name] = [table_schema, table_prim_key]
        self.create_table()

    def create_table(self):
        # Create a table (if it doesn't exist)
        for (table_name, vals) in self.table_name_schema_dict.items():
            [schema, primary_keys] = vals 
            self.cursor.execute(f'''
                CREATE TABLE IF NOT EXISTS {table_name} (
                    {','.join(key + ' ' + val for (key, val) in schema.items())},
                    PRIMARY KEY ({','.join(primary_keys)})
                ) 
            ''')
            self.connection.commit()

    def extract_schema_dict(self):

        # Get all user-defined table names (exclude internal SQLite tables)
        self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';")
        tables = [row[0] for row in self.cursor.fetchall()]

        table_name_schema_dict = {}

        for table in tables:
            self.cursor.execute(f"PRAGMA table_info({table});")
            rows = self.cursor.fetchall()

            # Format: (cid, name, type, notnull, dflt_value, pk)
            column_dict = {}
            primary_keys = []

            for cid, name, col_type, notnull, default, pk in rows:
                column_dict[name] = col_type
                if pk > 0:
                    primary_keys.append(name)

            table_name_schema_dict[table] = [column_dict, primary_keys]

        return table_name_schema_dict

    def execute_query(self, query: str, args:tuple = None):
        '''
        NOTE: query input is any SQL query generated by text2sql that 
        '''
        if args is None:
            self.cursor.execute(query)
        else:
            self.cursor.execute(query, args)

        self.connection.commit()

        return self.cursor.fetchall()  # return all rows relevant to query
    
    def execute_many_queries(self, queries: str, args:tuple = None):
        '''
        NOTE: query input is any SQL query generated by text2sql that 
        '''
        try:
            self.cursor.executescript(queries)
            self.connection.commit()
            self.table_name_schema_dict = self.extract_schema_dict() #update the schema dictionary if we create new tables
            return self.cursor.fetchall()  # return all rows relevant to query
        except Exception as e:
            print(f"Error executing multiple queries: {e}")
            return None

    def insert_many_rows_list(self, table_name:str, rows_data: list):
        table_schema = self.table_name_schema_dict[table_name]
        schema_prompt = tuple(table_schema[0].keys())
        schema_value_prompt = ','.join(['?' for _ in range(len(table_schema[0].keys()))])
        
        query = self.insertion_query.format(table_name = table_name, table_schema = schema_prompt, table_schema_value = schema_value_prompt)

        # Insert multiple rows at once using executemany()
        self.cursor.executemany(query, rows_data)

        self.connection.commit()
    
    def extract_all_rows(self, table_name:str):
        return  self.execute_query(query=f"SELECT * FROM {table_name};")
    
    def get_total_num_rows(self, table_name):
        #get total number of rows in table
        self.cursor.execute(f"SELECT COUNT(*) FROM {table_name}")
        num_rows = int(self.cursor.fetchone()[0])
        return num_rows

    def extract_concatenated_captions(self, table_name:str, attribute:str, num_rows:int = 40):
        # SQL query to get combined description
        query = f"""
            SELECT GROUP_CONCAT({attribute}, ' ') AS combined_{attribute}
            FROM (
                SELECT {attribute} FROM {table_name} LIMIT ?
            )
        """

        self.cursor.execute(query, (num_rows,))
        result = self.cursor.fetchone()
        combined_description = result[0] if result[0] else ''

        return combined_description

    # Unused function
    # def insert_many_rows_dict(self, rows_data: dict):

    #     table_schema = self.table_name_caption_dict[table_name]
    #     schema_prompt = tuple(table_schema.keys() if table_schema is None else table_schema.keys())
    #     schema_value_prompt = ','.join(['?' for _ in range(table_schema.keys() if table_schema is None else table_schema.keys())])
        
    #     query = self.insertion_query.format(table_name = table_name, table_schema = schema_prompt, table_schema_value = schema_value_prompt)


    #     # Execute query with extracted values
    #     self.cursor.executemany(query, [tuple(d.values()) for d in rows_data])

    #     # Commit changes and close connection
    #     self.connection.commit()

    def close_conn(self):

        self.cursor.close()
    
    def get_schema(self, tables_to_include:Set[str]=None):
        """
        Extracts the schema information from specific tables in an SQLite database.

        Parameters:
            db_file (str): Path to the SQLite database file.
            tables_to_include (list of str): List of table names to include in the schema.

        Returns:
            str: The schema of specified tables, including column details.
        """
        try:
            # Verify table names against sqlite_master
            self.cursor.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name != '{Config.caption_table_name}';")
            all_tables = {row[0] for row in self.cursor.fetchall()}

            # Filter only existing tables
            valid_tables = all_tables if tables_to_include is None else [t for t in all_tables if t in tables_to_include]
            if len(valid_tables) == 0:
                return "None of the specified tables exist in the database."

            schema_info = []

            for table_name in valid_tables:
                schema_info.append(f"Table: {table_name}")

                # Get column details
                self.cursor.execute(f"PRAGMA table_info({table_name});")
                columns = self.cursor.fetchall()

                for col in columns:
                    col_id, col_name, col_type, _, _, _ = col
                    schema_info.append(f"  - {col_name} ({col_type})")

                schema_info.append("")  # Add space between tables

            # self.connection.close()
            return "\n".join(schema_info)

        except Exception as e:
            self.connection.close()
            return f"Error retrieving schema: {str(e)}"





