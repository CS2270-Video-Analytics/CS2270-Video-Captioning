import sqlite3
import sys
import os
sys.path.append('..')
from config import Config
from typing import List, Dict 

class SQLLiteDBInterface():

    def __init__(self, db_name:str = None, table_name_caption_dict:Dict = None):
        # Connect to SQLite database (or create it if it doesn't exist)
        self.connection = sqlite3.connect(os.path.join(Config.sql_db_path, Config.sql_db_name if db_name is None else db_name))
        self.cursor = connection.cursor()

        if table_name_caption_dict None:
            self.table_name_caption_dict = {Config.caption_table_name: Config.caption_table_schema, Config.processed_table_name : Config.processed_table_schema, Config.vector_table_name:Config.vector_table_schema}
        else:
            self.table_name_caption_dict = table_name_caption_dict
        
        
        #create the table during the init
        self.create_table()

        # self.insertion_query = f"INSERT INTO {self.table_name} {tuple(Config.caption_schema.keys() if caption_schema is None else caption_schema.keys())} VALUES ({','.join(['?' for _ in range(Config.caption_schema.keys() if caption_schema is None else caption_schema.keys())])})"
        self.insertion_query = "INSERT INTO {table_name} {table_schema} VALUES ({table_schema_value})"


    def create_table(self):

        # Create a table (if it doesn't exist)
        for (table_name, schema) in self.table_name_caption_dict.items():
            self.cursor.execute(f'''
                CREATE TABLE IF NOT EXISTS {table_name} (
                    {','.join(key + ' ' + val for (key, val) in schema.items())}
                )
            ''')
            self.connection.commit()

        

    def execute_query(self, query: str, args:tuple = None):
        '''
        NOTE: query input is any SQL query generated by text2sql that 
        '''
        if args is None:
            self.cursor.execute(query)
        else:
            self.cursor.execute(query, args)

        return self.cursor.fetchall()  # return all rows relevant to query

    def insert_many_rows_list(self, table_name:str, rows_data: list):
        
        table_schema = self.table_name_caption_dict[table_name]
        schema_prompt = tuple(table_schema.keys() if table_schema is None else table_schema.keys())
        schema_value_prompt = ','.join(['?' for _ in range(table_schema.keys() if table_schema is None else table_schema.keys())])
        
        query = self.insertion_query.format(table_name = table_name, schema_prompt = schema_prompt, schema_value_prompt = schema_value_prompt)

        # Insert multiple rows at once using executemany()
        self.cursor.executemany(query, rows_data)

        self.connection.commit()
    
    def extract_all_rows(self, table_name:str):
        return  self.execute_query(query=f"SELECT * FROM {table_name};")

    
    def insert_many_rows_dict(self, rows_data: dict):

        table_schema = self.table_name_caption_dict[table_name]
        schema_prompt = tuple(table_schema.keys() if table_schema is None else table_schema.keys())
        schema_value_prompt = ','.join(['?' for _ in range(table_schema.keys() if table_schema is None else table_schema.keys())])
        
        query = self.insertion_query.format(table_name = table_name, schema_prompt = schema_prompt, schema_value_prompt = schema_value_prompt)


        # Execute query with extracted values
        self.cursor.executemany(query, [tuple(d.values()) for d in rows_data])

        # Commit changes and close connection
        self.connection.commit()

    def close_conn(self):

        self.cursor.close()
    
    def get_schema(self):
        """
        Extracts the schema information from an SQLite database.

        Parameters:
            db_file (str): Path to the SQLite database file.

        Returns:
            str: The database schema, including table names and column details.
        """
       
        try:
            # Get all table names
            self.cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tables = self.cursor.fetchall()
            if not tables:
                raise Exception("There should be tables in the DB for this method to work!")

            schema_info = []

            for table_name in tables:
                table_name = table_name[0]
                schema_info.append(f"Table: {table_name}")

                # Get column details
                self.cursor.execute(f"PRAGMA table_info({table_name});")
                columns = self.cursor.fetchall()

                for col in columns:
                    col_id, col_name, col_type, _, _, _ = col
                    schema_info.append(f"  - {col_name} ({col_type})")

                schema_info.append("\n")  # Add space between tables

            self.connection.close()
            return "\n".join(schema_info)  # Return formatted schema

        except Exception as e:
            self.connection.close()
            return f"Error retrieving schema: {str(e)}"





